{"version":3,"sources":["components/AutoComplete/index.js","config.js","mapHelper.js","App.js","index.js"],"names":["AutoComplete","_ref","source","showAutoComplete","value","onChange","suggestions","onHasError","hasError","_","filter","stationsName","toLowerCase","indexOf","length","i","react_default","a","createElement","className","e","target","map","inx","key","concat","onClick","config","logEnable","MAX","log","data","console","getConnectedStation","station","ret","line","push","initGraph","stationsData","vertex","graph","vertexes","totalCount","_loop2","connectLines","stationName","name","connectedLines","_loop3","lineName","supportedStations","currentPositionUnCheck","minLeft","minRight","minLeftName","minRightName","connectedStationsName","stationPosition","currentPosition","findMostCloseStation","targetPosition","distance","weight","lines","Array","isArray","currentPositionArray","targetPositionArray","_currentPosition","_targetPosition","min","j","Math","abs","findWay","baseStationVertexes","baseGraph","start","end","stationVertexes","isLineVertex","path","hasAccessed","startLines","startLine","targetVertexName","connectVertexName","targetVertexLines","targetVertexLine","stationChangeTimes","findStationChangeTimes","currentLineName","stationInfo","App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","state","assign","startStation","endStation","displayPath","searchEnable","selectedOption","circleLineNames","stationNames","lineChangeMap","passLines","slice","splice","connectedLine","_loop","sort","b","find","initData","detectSearchEnable","prevProps","prevState","snapshot","_this2","components_AutoComplete","onStartPositionChange","onEndPositionChange","doSearch","disabled","type","checked","changeEvent","setState","pathDisplay","targetPathAndWeight","minChangeTimes","lessStation","findLessChangeWay","displayPathToUser","currentStationName","currentKeepStationName","Component","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.5f51473a.chunk.js","sourcesContent":["import _ from 'lodash';\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport styles from './styles.css';\n\nconst AutoComplete = ({ source, showAutoComplete, value, onChange, onHasError }) => {\n  let suggestions = [];\n  let hasError = false;\n  if (value) {\n    suggestions = _.filter(source, (stationsName) => {\n      return stationsName.toLowerCase().indexOf(value.toLowerCase()) >= 0;\n    });\n    if (suggestions.length === 0) {\n      hasError = true;\n    }\n    for (let i = 0; i < source.length; i++) {\n      if (source[i] === value) {\n        suggestions = [];\n        hasError = false;\n      } else if (source[i].toLowerCase() === value.toLowerCase()) {\n        suggestions = [];\n        hasError = false;\n        onChange(source[i]);\n      }\n    }\n  }\n  return (\n    <div className={ showAutoComplete && suggestions.length > 0 ? 'auto-complete-wrap auto-complete-wrap-up' : 'auto-complete-wrap' }>\n      <input className=\"input-item\"\n             value={ value }\n             onChange={ (e) => {\n               onChange(e.target.value);\n             } }/>\n      <div className={ showAutoComplete && suggestions.length > 0 ? 'complete-wrap' : 'complete-none' }>\n        <ul className=\"suggestion-wrap\">\n          {\n            suggestions.map((value, inx) => (\n              <li key={ `_${inx}` } onClick={ () => {\n                onChange(value);\n              } } className=\"suggestion-item\">{ value }</li>\n            ))\n          }\n        </ul>\n      </div>\n      <div className={ hasError ? 'has-error-wrap' : 'has-error-none' }>\n        Please input correct station\n      </div>\n    </div>\n  );\n};\n\nAutoComplete.propTypes = {\n  source: PropTypes.array,\n  showAutoComplete: PropTypes.bool,\n  onChange: PropTypes.func,\n  value: PropTypes.string,\n};\n\nexport default AutoComplete;\n","export default {\n  logEnable: true,\n  max: 500,\n};","import _ from 'lodash';\nimport config from './config';\n\nconst logEnable = config.logEnable;\nconst MAX = config.max;\n\nfunction log(data) {\n  if (logEnable) {\n    console.log(data);\n  }\n}\n\n// init the map data, with lines and vertexes (the station with has more the one line pass)\nexport function initData(stationsData) {\n  const circleLineNames = []; // store circle line name ,eg: BP\n  const stationNames = []; // line: [], // store station line\n  const lines = {};\n  const lineChangeMap = {};\n  const stationVertexes = [];\n\n  for (let station in stationsData) {\n    stationNames.push(station);\n    const stationInfo = stationsData[station];\n    const passLines = [];\n    for (let lineName in stationInfo) {\n      // init line change map keys\n      if (!lineChangeMap[lineName]) {\n        lineChangeMap[lineName] = {};\n      }\n      passLines.push(lineName);\n\n      // put station info into lines data\n      if (!lines[lineName]) {\n        lines[lineName] = [];\n      }\n      const value = stationInfo[lineName];\n      if (Array.isArray(value)) {\n        // is circle line\n        if (circleLineNames.indexOf(lineName) < 0) {\n          circleLineNames.push(lineName);\n        }\n        for (let i = 0; i < value.length; i++) {\n          lines[lineName].push({\n            name: station,\n            value: value[i],\n          });\n        }\n      } else {\n        lines[lineName].push({\n          name: station,\n          value,\n        });\n      }\n    }\n    // put station change map\n    if (passLines.length > 1) {\n      stationVertexes.push({\n        name: station,\n        isLineVertex: false,\n        connectedLines: passLines,\n      });\n      for (let i = 0; i < passLines.length; i++) {\n        const lineName = passLines[i];\n        const connectedLines = passLines.slice();\n        connectedLines.splice(connectedLines.indexOf(lineName), 1);\n        for (let i = 0; i < connectedLines.length; i++) {\n          let connectedLine = connectedLines[i];\n          if (!lineChangeMap[lineName][connectedLine]) {\n            lineChangeMap[lineName][connectedLine] = [];\n          }\n          lineChangeMap[lineName][connectedLine].push(station);\n        }\n      }\n    }\n  }\n\n  for (let lineName in lines) {\n    lines[lineName].sort(function(a, b) {\n      return a.value - b.value;\n    });\n    const length = lines[lineName].length;\n    if (!_.find(stationVertexes, (station) => {\n        return station.name === lines[lineName][0].name;\n      })) {\n      stationVertexes.push({\n        name: lines[lineName][0].name,\n        isLineVertex: true,\n        connectedLines: getConnectedStation(stationsData[lines[lineName][0].name]),\n      });\n    }\n    if (!_.find(stationVertexes, (station) => {\n        return station.name === lines[lineName][length - 1].name;\n      })) {\n      stationVertexes.push({\n        name: lines[lineName][length - 1].name,\n        isLineVertex: true,\n        connectedLines: getConnectedStation(stationsData[lines[lineName][length - 1].name]),\n      });\n    }\n  }\n\n  const graph = initGraph(stationsData, stationVertexes);\n\n  const data = {\n    stationNames,\n    graph,\n    circleLineNames,\n    lineChangeMap,\n    lines,\n    stationVertexes,\n  };\n  log('init map data >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>');\n  log('lines : store all line with station in order');\n  log('stationNames: all the station names, user for name map and auto complete');\n  log('circleLineNames: all circle line name');\n  log('lineChangeMap: all station enable line A change to line B');\n  log('graph: base graph, only store station with different line pass');\n  log('stationVertexes: base vertexes, station can direct go to which line');\n  log(data);\n  return data;\n}\n\nexport function getConnectedStation(station) {\n  const ret = [];\n  for (let line in station) {\n    ret.push(line);\n  }\n  return ret;\n}\n\nexport function initGraph(stationsData, vertex) {\n  // graph is a key object, store all the station with vertex and line with weight.\n  // start station, end station, station with multiple line pass all consider as vertex;\n  const graph = {\n    vertexes: {},\n    totalCount: 0,\n  };\n  for (let i = 0; i < vertex.length; i++) {\n    const connectLines = [];\n    const stationName = vertex[i].name;\n    const connectedLines = vertex[i].connectedLines;\n\n    for (let i = 0; i < connectedLines.length; i++) {\n      const lineName = connectedLines[i];\n      const supportedStations = _.filter(vertex, (station) => {\n        return station.connectedLines.indexOf(lineName) >= 0 && station.name !== stationName;\n      });\n\n      // add line to the closest vertex, coz current postion maybe an array\n      let currentPositionUnCheck = stationsData[stationName][lineName];\n\n      let minLeft = MAX;\n      let minRight = MAX;\n      if (supportedStations.length === 0) {\n        // is circle line\n        continue;\n      }\n      let minLeftName = supportedStations[0].name;\n      let minRightName = supportedStations[0].name;\n      for (let i = 0; i < supportedStations.length; i++) {\n        const connectedStationsName = supportedStations[i].name;\n        let stationPosition = stationsData[connectedStationsName][lineName];\n        // handle circle line logic, find the most close position, take as weight\n        let currentPosition = findMostCloseStation(currentPositionUnCheck, stationPosition).currentPosition;\n        stationPosition = findMostCloseStation(currentPosition, stationPosition).targetPosition;\n\n        if (stationPosition > currentPosition) {\n          let distance = stationPosition - currentPosition;\n          if (distance < minRight) {\n            minRight = distance;\n            minRightName = connectedStationsName;\n          }\n        } else {\n          let distance = currentPosition - stationPosition;\n          if (distance < minLeft) {\n            minLeft = distance;\n            minLeftName = connectedStationsName;\n          }\n        }\n      }\n      if (minLeft !== MAX) {\n        connectLines.push({\n          lineName,\n          name: minLeftName,\n          weight: minLeft,\n        });\n      }\n      if (minRight !== MAX) {\n        connectLines.push({\n          lineName,\n          name: minRightName,\n          weight: minRight,\n        });\n      }\n    }\n    graph.vertexes[vertex[i].name] = {};\n    graph.vertexes[vertex[i].name].lines = connectLines;\n    graph.totalCount++;\n  }\n  console.log(graph);\n  return graph;\n}\n\nexport function findMostCloseStation(currentPosition, targetPosition) {\n\n  const ret = {};\n  if (!Array.isArray(currentPosition)) {\n    ret.currentPosition = currentPosition;\n  }\n  if (!Array.isArray(targetPosition)) {\n    ret.targetPosition = targetPosition;\n  }\n  if (Array.isArray(currentPosition)) {\n    ret.currentPosition = currentPosition[0];\n  }\n  if (Array.isArray(targetPosition)) {\n    ret.targetPosition = targetPosition[0];\n  }\n\n  if (Array.isArray(currentPosition) || Array.isArray(targetPosition)) {\n    const currentPositionArray = [].concat(currentPosition);\n    const targetPositionArray = [].concat(targetPosition);\n\n    let _currentPosition = currentPositionArray[0];\n    let _targetPosition = targetPositionArray[0];\n    let min = MAX;\n    for (let i = 0; i < currentPositionArray.length; i++) {\n      for (let j = 0; j < targetPositionArray.length; j++) {\n        const distance = Math.abs(currentPositionArray[i] - targetPositionArray[j]);\n        if (distance < min) {\n          _currentPosition = currentPositionArray[i];\n          _targetPosition = targetPositionArray[j];\n          min = distance;\n        }\n      }\n    }\n\n    ret.currentPosition = _currentPosition;\n    ret.targetPosition = _targetPosition;\n  }\n\n  return ret;\n}\n\nexport function findWay(stationsData, baseStationVertexes, baseGraph, start, end) {\n  log('findWay >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>');\n  log('start:' + start);\n  log('end:' + end);\n  let stationVertexes = baseStationVertexes;\n  let graph = baseGraph;\n  let vertexes = graph.vertexes;\n  if (!vertexes[start] || !vertexes[end]) {\n    // if the start or end station not in the stationVertexes, need to rebuild the graph\n    if (!vertexes[start]) {\n      stationVertexes.push({\n        name: start,\n        isLineVertex: true,\n        connectedLines: getConnectedStation(stationsData[start]),\n      });\n    }\n    if (!vertexes[end]) {\n      stationVertexes.push({\n        name: end,\n        isLineVertex: true,\n        connectedLines: getConnectedStation(stationsData[end]),\n      });\n    }\n    graph = initGraph(stationsData, stationVertexes);\n    vertexes = graph.vertexes;\n  }\n\n  const totalCount = graph.totalCount;\n  const map = {};\n  for (let vertex in vertexes) {\n    if (vertex !== vertexes[start]) {\n      map[vertex] = {\n        weight: MAX,\n        path: [],\n      };\n    }\n  }\n  const hasAccessed = [];\n  const startLines = vertexes[start].lines;\n  for (let i = 0; i < startLines.length; i++) {\n    const startLine = startLines[i];\n    if (startLine.weight < map[startLine.name].weight) {\n      map[startLine.name].weight = startLine.weight;\n      map[startLine.name].path = [\n        {\n          stationName: start,\n          lineName: startLine.lineName,\n        }].concat({\n        stationName: startLine.name,\n        lineName: startLine.lineName,\n      });\n    }\n  }\n  // access the least distance vertex;\n  for (let i = 1; i < totalCount; i++) {\n    let min = MAX;\n    let targetVertexName = null;\n    for (let connectVertexName in map) {\n      if (hasAccessed.indexOf(connectVertexName) < 0 && min >= map[connectVertexName].weight) {\n        min = map[connectVertexName].weight;\n        targetVertexName = connectVertexName;\n      }\n    }\n    if (targetVertexName) {\n      hasAccessed.push(targetVertexName);\n      const targetVertex = vertexes[targetVertexName];\n      const targetVertexLines = targetVertex.lines;\n      for (let i = 0; i < targetVertexLines.length; i++) {\n        const targetVertexLine = targetVertexLines[i];\n        if (targetVertexLine.weight + min < map[targetVertexLine.name].weight) {\n          map[targetVertexLine.name].weight = targetVertexLine.weight + min;\n          map[targetVertexLine.name].path = map[targetVertexName].path.concat(\n            {\n              stationName: targetVertexLine.name,\n              lineName: targetVertexLine.lineName,\n            });\n        }\n      }\n    }\n  }\n  log('least distance map');\n  log(map);\n  log('target path');\n  log(map[end]);\n  map[end].stationChangeTimes = findStationChangeTimes(map[end].path);\n  return map[end];\n}\n\nexport function findLessChangeWay(stationsData, baseStationVertexes, baseGraph, start, end) {\n  log('findLessChangeWay >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>');\n  log('start:' + start);\n  log('end:' + end);\n  let stationVertexes = baseStationVertexes;\n  let graph = baseGraph;\n  let vertexes = graph.vertexes;\n  if (!vertexes[start] || !vertexes[end]) {\n    // if the start or end station not in the stationVertexes, need to rebuild the graph\n    if (!vertexes[start]) {\n      stationVertexes.push({\n        name: start,\n        isLineVertex: true,\n        connectedLines: getConnectedStation(stationsData[start]),\n      });\n    }\n    if (!vertexes[end]) {\n      stationVertexes.push({\n        name: end,\n        isLineVertex: true,\n        connectedLines: getConnectedStation(stationsData[end]),\n      });\n    }\n    graph = initGraph(stationsData, stationVertexes);\n    vertexes = graph.vertexes;\n  }\n\n  const totalCount = graph.totalCount;\n  const map = {};\n  for (let vertex in vertexes) {\n    if (vertex !== vertexes[start]) {\n      map[vertex] = {\n        weight: MAX,\n        path: [],\n        stationChangeTimes: MAX,\n      };\n    }\n  }\n  const hasAccessed = [];\n  const startLines = vertexes[start].lines;\n  for (let i = 0; i < startLines.length; i++) {\n    const startLine = startLines[i];\n    const stationChangeTimes = findStationChangeTimes([\n      {\n        stationName: start,\n        lineName: startLine.lineName,\n      }].concat({\n      stationName: startLine.name,\n      lineName: startLine.lineName,\n    }));\n    if (stationChangeTimes < map[startLine.name].stationChangeTimes) {\n      map[startLine.name].weight = startLine.weight;\n      map[startLine.name].path = [\n        {\n          stationName: start,\n          lineName: startLine.lineName,\n        }].concat({\n        stationName: startLine.name,\n        lineName: startLine.lineName,\n        stationChangeTimes,\n      });\n      map[startLine.name].stationChangeTimes = stationChangeTimes;\n    }\n  }\n  // access the least distance vertex;\n  for (let i = 1; i < totalCount; i++) {\n    let min = MAX;\n    let minChangeTimes = MAX;\n    let targetVertexName = null;\n    for (let connectVertexName in map) {\n      if (hasAccessed.indexOf(connectVertexName) < 0 && minChangeTimes >= map[connectVertexName].stationChangeTimes) {\n        minChangeTimes = map[connectVertexName].stationChangeTimes;\n        targetVertexName = connectVertexName;\n        min = map[connectVertexName].weight;\n      }\n    }\n    if (targetVertexName) {\n      hasAccessed.push(targetVertexName);\n      const targetVertex = vertexes[targetVertexName];\n      const targetVertexLines = targetVertex.lines;\n      for (let i = 0; i < targetVertexLines.length; i++) {\n        const targetVertexLine = targetVertexLines[i];\n        const stationChangeTimes = findStationChangeTimes(\n          map[targetVertexName].path.concat(\n            {\n              stationName: targetVertexLine.name,\n              lineName: targetVertexLine.lineName,\n            }),\n        );\n        if (stationChangeTimes < map[targetVertexLine.name].stationChangeTimes\n          || (stationChangeTimes === map[targetVertexLine.name].stationChangeTimes &&\n            targetVertexLine.weight + min < map[targetVertexLine.name].weight\n          )\n        ) {\n          map[targetVertexLine.name].stationChangeTimes = targetVertexLine.stationChangeTimes + min;\n          map[targetVertexLine.name].path = map[targetVertexName].path.concat(\n            {\n              stationName: targetVertexLine.name,\n              lineName: targetVertexLine.lineName,\n            });\n          map[targetVertexLine.name].weight = targetVertexLine.weight + min;\n          map[targetVertexLine.name].stationChangeTimes = stationChangeTimes;\n        }\n      }\n    }\n  }\n  log('least change map');\n  log(map);\n  log('target path');\n  log(map[end]);\n\n  // need improve this logic\n  const lessStation = findWay(stationsData, baseStationVertexes, baseGraph, start, end);\n  if (lessStation.stationChangeTimes === map[end].stationChangeTimes && lessStation.weight < map[end].weight) {\n    return lessStation;\n  }\n  return map[end];\n}\n\nexport function findStationChangeTimes(path) {\n  let currentLineName = path[0].lineName;\n  let ret = 0;\n  for (let i = 1; i < path.length; i++) {\n    const stationInfo = path[i];\n    if (stationInfo.lineName !== currentLineName) {\n      ret++;\n      currentLineName = stationInfo.lineName;\n    }\n  }\n  return ret;\n}\n","import React, { Component } from 'react';\nimport AutoComplete from './components/AutoComplete';\nimport { initData, findWay, findLessChangeWay } from './mapHelper';\nimport stationsData from './stations.json';\nimport './App.css';\nimport config from './config';\n\nconst logEnable = config.logEnable;\n\nclass App extends Component {\n\n  constructor(props) {\n    super(props);\n    this.state = Object.assign({\n      startStation: 'Jurong East',\n      endStation: 'Chinatown',\n      displayPath: [],\n      searchEnable: false,\n      selectedOption: '0',\n    }, initData(stationsData));\n  }\n\n  componentDidMount() {\n    this.detectSearchEnable(this.state.startStation, this.state.endStation);\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n\n  }\n\n  render() {\n    return (\n      <div className=\"wrap\">\n        <h2 className=\"welcome\">\n          Thanks you using SG MRT\n        </h2>\n        <div className=\"input-wrap\">\n          <span className=\"label\">Start Station:</span>\n          <AutoComplete\n            value={ this.state.startStation }\n            onChange={\n              (value) => {\n                this.onStartPositionChange(value);\n              } }\n            source={ this.state.stationNames }\n            showAutoComplete={ true }/>\n          <span className=\"separator\"></span>\n          <span className=\"label\">End Station:</span>\n          <AutoComplete\n            value={ this.state.endStation }\n            onChange={ (value) => {\n              this.onEndPositionChange(value);\n            } }\n            source={ this.state.stationNames }\n            showAutoComplete={ true }/>\n        </div>\n        <div className=\"search-wrap\">\n          <button className=\"search\" onClick={ () => {\n            this.doSearch();\n          } } disabled={ !this.state.searchEnable }>Search</button>\n          <div className=\"radio-wrap\">\n            <label>\n              <input type=\"radio\"\n                     value=\"0\"\n                     checked={ this.state.selectedOption === '0' }\n                     onChange={ (changeEvent) => {\n                       this.setState({\n                         selectedOption: changeEvent.target.value,\n                       });\n                     } }/>\n              Least station\n            </label>\n            <label>\n              <input type=\"radio\"\n                     value=\"1\"\n                     checked={ this.state.selectedOption === '1' }\n                     onChange={ (changeEvent) => {\n                       this.setState({\n                         selectedOption: changeEvent.target.value,\n                       });\n                     } }/>\n              Least line change\n            </label>\n          </div>\n        </div>\n        { this.state.displayPath.length > 0 &&\n        <ul className=\"result-wrap\">\n          {\n            this.state.displayPath.map((pathDisplay, inx) => (\n              <li key={ `r_${inx}` } className=\"result-item\">{ pathDisplay }</li>\n            ))\n          }\n        </ul> }\n      </div>\n    );\n  }\n\n  onStartPositionChange(value) {\n    this.setState({\n      startStation: value,\n    });\n    this.detectSearchEnable(value, this.state.endStation);\n  }\n\n  onEndPositionChange(value) {\n    this.setState({\n      endStation: value,\n    });\n    this.detectSearchEnable(this.state.startStation, value);\n  }\n\n  detectSearchEnable(startStation, endStation) {\n    if (this.state.stationNames.indexOf(startStation) >= 0 && this.state.stationNames.indexOf(endStation) >= 0) {\n      this.setState({\n        searchEnable: true,\n      });\n    } else {\n      this.setState({\n        searchEnable: false,\n      });\n    }\n  }\n\n  doSearch() {\n    if (!this.state.searchEnable) {\n      return;\n    }\n    if (this.state.selectedOption === '1') {\n      const targetPathAndWeight = findLessChangeWay(\n        stationsData,\n        this.state.stationVertexes,\n        this.state.graph,\n        this.state.startStation,\n        this.state.endStation);\n      this.displayPathToUser(targetPathAndWeight);\n    } else {\n      const targetPathAndWeight = findWay(\n        stationsData,\n        this.state.stationVertexes,\n        this.state.graph,\n        this.state.startStation,\n        this.state.endStation);\n      this.displayPathToUser(targetPathAndWeight);\n    }\n  }\n\n  //Take <line> from <station> to <station>\n  //Change to <line>\n  displayPathToUser(targetPathAndWeight) {\n    const path = targetPathAndWeight.path;\n    const displayPath = [];\n    if (!path || path.length === 0) {\n      displayPath.push('Sorry, can\\'t find the way to this station, please contact admin to get more support');\n      this.setState({\n        displayPath,\n      });\n      return;\n    }\n    let currentLineName = path[0].lineName;\n    let currentStationName = path[0].stationName;\n    let currentKeepStationName = '';\n    for (let i = 1; i < path.length; i++) {\n      const stationInfo = path[i];\n      if (stationInfo.lineName === currentLineName) {\n        //not need to change line;\n        if (i === path.length - 1) {\n          // is final station;\n          displayPath.push(`Take ${ currentLineName } from ${ currentStationName } to ${ stationInfo.stationName }`);\n        } else {\n          currentKeepStationName = stationInfo.stationName;\n        }\n      } else {\n        displayPath.push(`Take ${ currentLineName } from ${ currentStationName } to ${ currentKeepStationName }`);\n        displayPath.push(`Change to ${ stationInfo.lineName }`);\n        currentStationName = stationInfo.stationName;\n        currentLineName = stationInfo.lineName;\n        if (i === path.length - 1) {\n          displayPath.push(\n            `Take ${ currentLineName } from ${ currentKeepStationName } to ${ stationInfo.stationName }`);\n        }\n      }\n    }\n    displayPath.push(\n      `Total ${targetPathAndWeight.weight} station you will pass, and need to change line ${targetPathAndWeight.stationChangeTimes} times`);\n    this.log(displayPath);\n    this.setState({\n      displayPath,\n    });\n  }\n\n  log(data) {\n    if (logEnable) {\n      console.log(data);\n    }\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\n"],"sourceRoot":""}